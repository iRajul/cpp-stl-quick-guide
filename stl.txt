Made this guide as a notes after reading Effective STL by scott meyers
==================================
STRING AND VECTOR
==================================

Item 13. Prefer vector and string to dynamically allocated arrays.
string implementation may involve refernce counting so must see their document or use vector<char>
-----------------------------------------------------

Item 14. Use reserve to avoid unnecessary reallocations.

vector<int> v;
v.reserve(1000);
for (int i = 1; i <= 1000; ++i) v.push_back(i);
This should result in zero reallocations during the loop.

Reallocation in vector invalidate iterators, pointer and references

There are two common ways to use reserve to avoid unneeded reallocations. 
>> The first is applicable when you know exactly or approximately how many elements will ultimately end up in your container. 
In that case, as in the vector code above, you simply reserve the appropriate amount of space in advance. 

>> The second way is to reserve the maximum space you could ever need. then, once you've added all your data, trim off any excess capacity.

--------------------------------------------------------

Item 15. Be aware of variations in string implementations. 
Different vendors can have different implementation of string.
string objects may range in size from one to at least seven times the size of char* pointers.

--------------------------------------------------------

Item 16. Know how to pass vector and string data to legacy APIs.
For vector:
if (!v.empty()) {
doSomething(&v[0], v.size());
}
Beware : Dont use v.begin() in place of &v[0]

For string:
c_str()

The approach to getting a pointer to container data that works for vectors isn't reliable for strings, because 
(1) the data for strings are not guaranteed to be stored in contiguous memory, and 
(2) the internal representation of a string is not guaranteed to end with a null character.

----------------------------------------------------------

Item 17. Use "the swap trick" to trim excess capacity
//shrink to fit
vector<Contestant>(contestants).swap(contestants); 
string(s).swap(s);

To clear container : 
vector<Contestant> v;
string s;
vector<Contestant>().swap(v); //clear v and minimize its capacity
string().swap(s); // clear s and minimize its capacity

----------------------------------------------------------

Item 18. Avoid using vector<bool>:
Two things wrong with vector<bool>. 
First, it's not an STL container. 
Second, it doesn't hold bools.

vector<bool> v;
bool *pb = &v[0]; // error! the expression on the right is of type vector<bool>::reference*, not bool*
Because it won't compile, vector<bool> fails to satisfy the requirements for STL containers.

Alternative to use : 
deque<bool> // it would not allocate in contiguous manner like vector.
bitset

----------------------------------------------------------


=====================================
ASSOCIATIVE CONTAINER
=====================================

Item 19. Understand the difference between equality and equivalence.
equality, which is based on operator==
Equivalence is based on the relative ordering of object values in a sorted range. !c.key_comp()(x, y) && !c.key_comp()(y, x)
The standard associative containers are kept in sorted order, so each container must have a comparison function (less, by default) that defines how to keep things sorted.

---------------------------------------------------------

Item 20. Specify comparison types for associative containers of pointers.
Anytime you create associative containers of pointers, figure you're probably going to have to specify the container's comparison type, too. 
Most of the time, your comparison type will just dereference the pointers and compare the pointed-to objects.
struct DereferenceLess {
template <typename PtrType>
bool operator()(PtrType pT1, // parameters are passed by
		PtrType pT2) const // value, because we expect them
	{   // to be (or to act like) pointers
		return *pT1 < *pT2;
	}
};


Usage : set<string*, DereferenceLess> ssp;

---------------------------------------------------------

Item 21. Always have comparison functions return false for equal values.

---------------------------------------------------------

Item 22. Avoid in-place key modification in set and multiset.

Key is const in map and multimap but it is non-const in set and multi-set but some vendors provide const key in set too. 

Dont modify key in set as it can corrupt sorting order of keys in set.
If you want to modify content of key which is not  a part of comparator then do it like this: 
if (i != se.end()) { // cast away
	const_cast<Employee&>(*i).setTitle("Corporate Deity"); //constness
}
Use "Employee&" not "Employee" because by using "Employee" it will modify temporary object not actual object.

Or 
Follow five step process:
EmplDSet::iterator i =
se.find(selectedlD); // Step 1: find element to change

if(i!=se.end()){
	Employee e(*i); // Step 2: copy the element
	se.erase(i++); // Step 3: remove the element; increment the iterator to maintain its validity (see Item 9)
	e.setTitle("Corporate Deity"); // Step 4: modify the copy
	se.insert(i, e); // Step 5: insert new value; hint that its location is the same as that of the
}
------------------------------------------------------------

Item 23. Consider replacing associative containers with sorted vectors.

Assuming our data structures are big enough, they'll be split across multiple memory pages, but the vector will require fewer pages than the associative container.
Bottom Line : 
Storing data in a sorted vector is likely to consume less memory than storing the same data in a standard associative container, and searching a sorted vector via binary search is likely to be faster than searching a standard associative container when page faults are taken into account.
You need to write comparator for pair<key,value> if you choose vector instead of associative container.

When to use sorted vector over associative containers:
your program uses the data structure in the phased manner that is first only insertions and then only lookups
It makes sense to consider using a sorted vector instead of an associative container only when you know that your data structure is used in such a way that lookups are almost never mixed with insertions and erasures because inserting on sorted vector can be expensive operation.

-------------------------------------------------------------

Item 24. Choose carefully between map::operator[] and map-insert when efficiency is important
when an "add" is performed, map-insert saves you three function calls: 
1) one to create a temporary default-constructed Widget object, 
2) one to destruct that temporary object, and 
3) one to Widget's assignment operator.

operator[] is preferable when updating the value of an element that's already in the map.	
m[k] = v; // use operator[] to update k's value to be v

m.insert(
	IntWidgetMap::value_type(k, v)).first->second = v; // use insert to update k's value to be v

-------------------------------------------------------------
